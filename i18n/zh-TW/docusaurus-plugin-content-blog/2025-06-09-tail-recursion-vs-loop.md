---
authors:
- bater
date: '2025-06-09'
slug: tail-recursion-vs-loop
tags:
- Recursion
- Iteration
- TCO
- SICP
- Functional Programming
title: 尾遞迴 vs 迴圈：從 SICP 學到的以及為什麼它很重要
---

今天我在學習《電腦程式的構造和解釋（SICP）》時深入研究了**尾遞迴**的概念，而一開始只是好奇心，最終重塑了我對程式設計中效能、遞迴和控制流程的思考方式。

<!-- truncate -->

以下是我的技術反思和學習總結。

---

## 什麼是尾遞迴？

**尾遞迴**發生在遞迴函式的最後一個動作是遞迴呼叫時——呼叫之後沒有進一步的計算。

### 範例（Python）

```python
def factorial(n, acc=1):
    if n == 0:
        return acc
    return factorial(n - 1, acc * n)
```

這是尾遞迴，因為函式立即返回其遞迴呼叫的結果。

```python
def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)  # 不是尾遞迴
```
遞迴呼叫不是最後的操作——它還需要進行乘法運算。

## 為什麼尾遞迴有用？
當正確實作時，尾遞迴可以避免堆疊增長。在某些語言中，尾遞迴呼叫會被編譯器或直譯器最佳化以重用相同的堆疊框架，即使進行數百萬次呼叫也能實現高效遞迴。

這就是所謂的尾呼叫最佳化（TCO）。

## 哪些語言支援 TCO？

| 語言 | 尾呼叫最佳化 | 備註 |
|---------------|-----------------------------|----------------------------------------|
| Scheme | ✅ 是（規範要求） | 核心語言設計 |
| Haskell | ✅ 是（透過惰性求值） | 優雅的無限遞迴模式 |
| Elixir/Erlang | ✅ 是 | 對 actor 並發至關重要 |
| Scala | ⚠️ 需要 `@tailrec` | 需要註解 |
| Python | ❌ 否 | 深度遞迴時會堆疊溢位 |
| Java/C#/C++ | ❌ 否（不保證 TCO） | 最好使用迴圈 |


## 尾遞迴可以轉換成迴圈嗎？

當然可以。事實上，**每個尾遞迴函式都可以重構成迴圈**，因為所有狀態轉換都編碼在函式參數中。

### 關鍵轉換步驟：

| 遞迴 | 迴圈等價物 |
|----------------|-------------------|
| 參數 | 區域變數 |
| 遞迴呼叫 | 變數更新 |
| 基本情況 | 迴圈條件 |


## 範例：尾遞迴 → 迴圈（Python）
```python
def factorial(n, acc=1):
    if n == 0:
        return acc
    return factorial(n - 1, acc * n)
```
迭代版本：
```python
def factorial_iter(n):
    acc = 1
    while n > 0:
        acc *= n
        n -= 1
    return acc
```
這個重寫不使用額外的堆疊空間，在缺乏 TCO 的 Python 中效能更好。

## 尾遞迴 ≠ 高並發 ≠ n+1 問題
尾遞迴幫助單個執行避免堆疊溢位。

高並發是關於同時處理多個請求，取決於執行時模型（執行緒、非同步、actor 模型）。

n+1 查詢問題是資料庫存取效率問題，與遞迴或記憶體無關。

## 關鍵要點
尾遞迴不僅僅是一種模式——它是一種心智模型。

某些語言將尾呼叫視為可最佳化的，其他語言則不然。

你總是可以將尾遞迴函式重寫成迴圈以提高效能。

理解呼叫堆疊、函式框架和控制流程是朝著像系統級開發者一樣思考的一大步。

「要理解遞迴，首先必須理解遞迴。」
……也許還要理解堆疊、編譯器行為和記憶體管理 😉
