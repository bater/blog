---
authors:
- bater
date: '2025-08-04'
slug: ai-as-default-developer
tags:
- DevAiOps
- AI Developer
- Agent
- Prompt Engineering
- Human-in-the-loop
- Software 3.0
title: AI 作為預設開發者：我們將如何與機器共同編寫軟體？
---

在不久的將來，工程師不會被衡量他們寫了多少程式碼——而是被衡量他們設計的流程有多好地幫助 AI 寫出正確的程式碼。

<!-- truncate -->

## 從焦慮到覺醒：兩個真實故事

老實說，我最初與 AI 的接觸並不是很愉快。

兩年前，在一次技術面試中，我在一個限時編碼挑戰中失敗了。我沒能完成它，也沒有得到 offer。那天晚上我睡不著。出於好奇，我的伴侶接受了同樣的挑戰並把它輸入 ChatGPT（當時可能是 GPT-2.5）。幾秒鐘內，它就生成了一個可行的解決方案。我震驚了——坦白說，我被擊垮了。這讓我質疑我多年的程式設計專業知識是否即將變得過時。

另一個故事更加切身。我一直是 Clean Code 的堅定信仰者。我甚至基於 Code Smells 創建了一個重構指南，夢想有一天它可以成為開發者的 O'Reilly 書籍。但在大量實驗「氛圍編碼」——提示 AI 在幾秒鐘內生成可運作的程式碼——之後，我開始質疑：
**如果程式碼變成了一次性用品，風格和結構還有多重要？**

這些時刻迫使我問自己一個艱難的問題：
當 AI 能在幾秒鐘內完成過去需要我幾小時甚至幾天的事情時，
**工程師的價值還剩下什麼？**
我們是被取代了——還是被升級了？

---

## 範式轉變：從軟體 1.0 到 3.0

前特斯拉 AI 總監 Andrej Karpathy 對軟體如何演進提供了清晰的分解：

- **軟體 1.0** – 由人類逐行編寫的傳統程式碼（例如 C++、Python）
- **軟體 2.0** – 在資料上訓練的神經網路；「程式」就是模型權重
- **軟體 3.0** – LLM 透過提示生成軟體；自然語言成為程式語言

這不僅僅是工具的轉變。這是整個**軟體開發生命週期（SDLC）的根本重構**。

從 DevOps（開發和營運之間的協作）
→ 到 MLOps（模型和資料的生命週期管理）
→ 到 **DevAiOps**，
我們正在進入一個新時代，**AI 不是工具——而是預設的執行者**。

---

## AI 是預設，而非可選

在 AI 時代之前，典型的開發者工作流程是這樣的：

> **想法 → 規格 → 程式碼 → 測試 → 部署 → 監控**

然後出現了「AI 輔助」開發：

> 開發者有需求 → 發送提示（CLI 或網頁）→ 複製結果 → 手動整合

在 DevAiOps 模型中，流程翻轉了：

> 任務首先由 AI 處理 → 人類只在必要時介入 → 整個管道由 AI 驅動，人類審查

未來的開發者將更像**導演，而不是演員**——設定目標、定義約束、驗證輸出。AI 成為預設的執行者。

就像我們今天假設每個專案都使用 Git 和 CI/CD 一樣，我們應該開始假設：

> **「不用 AI」是例外，而非預設。**

---

## 焦點轉移：從編寫程式碼到定義規格

在 AI 驅動的生命週期（AI-DLC）中，工作流程變得更像這樣：

> 想法（人類）→ 規格（人類 + AI）→ 分解與生成（AI）→ 驗證（AI + 人類）→ 部署與監控（AI）

工程師的價值不再以**你寫了多少行程式碼**來衡量，而是以**你多清楚、多完整地定義規格和意圖**來衡量。

### 氛圍編碼的陷阱

許多開發者現在使用 AI 來生成程式碼，但他們**不保留提示**。這抹去了上下文、可追溯性和可維護性——就像發布沒有原始碼的二進位檔案。

你的提示或規格應該是**一等公民**，因為它：

1. **對齊人類理解**——跨 PM、法務、設計和工程
2. **保留原始意圖**，這是僅靠程式碼無法完全表達的
3. **實現多輸出生成**：後端、前端、測試、文件——甚至行銷文案

即使是 OpenAI 也使用公開的基於 Markdown 的模型規格來定義行為——這是他們稱為**信任錨點**的基礎。

---

## 人類在環：重新定義的工程師

在 DevAiOps 中，人類不是被移除——而是被提升。角色演變為：

- **提示架構師** – 設計多階段提示鏈
- **規格審查員** – 根據目標和邊緣案例驗證 AI 生成的規格
- **AI 協調者** – 協調多個代理跨任務和交接
- **安全與倫理守衛** – 確保合規性、隱私和公平性
- **品味制定者** – 定義團隊美學：API 設計、命名、UI 風格

在這個新世界中，工程師不會被評判他們寫了什麼——而是他們**設計了什麼 AI 系統來可靠地完成正確的工作**。

---

## 提示就是程式碼，代理就是模組

我們必須接受一個新的程式設計現實：

> **提示 = 邏輯，提示鏈 = 流程圖，代理 = 服務模組**

你將會：

- 編寫**可執行的規格**，既可被機器讀取又可被人類理解
- 建構**提示鏈**，協調任務、工具和思考過程
- 對你的提示進行版本控制，並為預期輸出創建單元測試
- **除錯 AI 行為**，就像你除錯邏輯一樣——透過追溯它的推理

這不是一個 hack。這是軟體工藝的新紀律。
**提示工程不是把戲——它是一項核心的 IDE 原生技能。**

---

## 結語：AI 是預設，而非例外

DevAiOps 不是關於「在你的開發堆疊中添加一些 AI」。
而是關於假設**AI 始終存在**——而手動編碼是例外。

在不久的將來，加入一個新倉庫不會涉及問：

> 「我可以用 ChatGPT 來幫助這個函式嗎？」

而是：

> - 「這個倉庫使用的是哪個版本的 CodeAgent 提示？」
> - 「我如何將更新的規格同步到我們的 RAG 知識庫？」
> - 「測試自動完成是否啟用？對於模糊提示，我們的後備策略是什麼？」

我們正在進入一個**人類意圖驅動 AI 執行**的世界。
在那個世界中，工程師不是被取代——而是被**提升**。
從編碼者到系統設計師。從打字員到協調者。

---

📍在下一篇文章中，我們將分解 DevAiOps 架構——從五個核心代理到它們的職責、資料流和協作模型。

📬 **訂閱以關注這個系列，並留下評論：
你的工作流程中哪個部分最準備好讓 AI 成為預設？**
